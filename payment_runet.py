# -*- coding: utf-8 -*-
import os
from flask import Flask, render_template_string, request, redirect, url_for, flash
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user
from werkzeug.security import generate_password_hash, check_password_hash
import json
import math
import re
import random
import datetime
from io import StringIO
from contextlib import redirect_stdout

# --- КОНФИГУРАЦИЯ ПРИЛОЖЕНИЯ ---
basedir = os.path.abspath(os.path.dirname(__file__))
app = Flask(__name__)
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'a_very_secret_key_that_should_be_changed')

# Используем персистентное хранилище на Render, если доступно
data_dir = os.environ.get('RENDER_DATA_DIR', basedir)
db_path = os.path.join(data_dir, 'runetcode.db')
app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{db_path}'

app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)
login_manager = LoginManager(app)
login_manager.login_view = 'login'
login_manager.login_message = "Пожалуйста, войдите в аккаунт, чтобы получить доступ к этой странице."

# --- ДАННЫЕ УРОКОВ (51 УРОК) ---
# (Этот блок оставлен без изменений, как вы и просили)
lessons = [
    # --- Блок 1: Основы и синтаксис (Уроки 1-14) ---
    {
        "title": 'Урок 1: Приветствие!',
        "instruction": 'Ваша первая задача — вывести на экран строку "Привет, мир!".\n\nТеория: Команда `вывести` — это инструкция, которая говорит компьютеру отобразить текст или значение на экране. Текст, который нужно вывести, называется строкой и заключается в двойные кавычки.',
        "example": 'Пример: `вывести "Python - это весело!"` выведет на экран соответствующую фразу.',
        "homework": 'Домашнее задание: Напишите программу, которая выводит ваше имя на экран.',
        "code": 'вывести "Привет, мир!"',
        "expectedOutput": 'Привет, мир!\n',
    },
    {
        "title": 'Урок 2: Переменные',
        "instruction": 'Создайте переменную `сообщение` со значением "Я учусь программировать!".\n\nТеория: Переменная — это как именованная коробка для хранения данных. Команда `установить` создает такую "коробку" и кладет в нее значение. Затем вы можете использовать имя переменной, чтобы получить доступ к этому значению.',
        "example": 'Пример: `установить мой_возраст в 25` создаст переменную `мой_возраст` и сохранит в ней число 25.',
        "homework": 'Домашнее задание: Создайте две переменные: `имя` и `город`. Присвойте им ваше имя и город, а затем выведите их на экран.',
        "code": 'установить сообщение в "Я учусь программировать!"\nвывести сообщение',
        "expectedOutput": 'Я учусь программировать!\n',
    },
    {
        "title": 'Урок 3: Арифметика',
        "instruction": 'Переменные могут хранить числа. Установите `число1` в `10` и `число2` в `5`. Затем выведите их сумму.\n\nТеория: Язык поддерживает стандартные арифметические операторы: `+` (сложение), `-` (вычитание), `*` (умножение), `/` (деление). Их можно применять к переменным, хранящим числа.',
        "example": 'Пример: `вывести 100 - 42` выведет на экран результат вычитания, число 58.',
        "homework": 'Домашнее задание: В магазине 3 яблока по 15 рублей и 2 банана по 20 рублей. Напишите программу, которая посчитает и выведет общую стоимость покупки.',
        "code": 'установить число1 в 10\nустановить число2 в 5\nвывести число1 + число2',
        "expectedOutput": '15\n',
    },
    {
        "title": 'Урок 4: Условные операторы (`если`)',
        "instruction": 'Программа может принимать решения. Используйте `если` для проверки, больше ли возраст `18`. Если да, выведите "Совершеннолетний.".\n\nТеория: Конструкция `если ... тогда ... конец` позволяет выполнять код только при соблюдении определенного условия. Условие — это выражение, которое возвращает "истину" или "ложь". Оператор `>` (больше чем) — это один из операторов сравнения.',
        "example": 'Пример: `установить пароль в "12345"\nесли пароль == "12345" тогда\n    вывести "Доступ разрешен"\nконец`',
        "homework": 'Домашнее задание: Создайте переменную `температура` со значением -5. Напишите программу, которая выводит "Холодно!", если температура ниже 0.',
        "code": 'установить возраст в 20\nесли возраст > 18 тогда\n    вывести "Совершеннолетний."\nконец',
        "expectedOutput": 'Совершеннолетний.\n',
    },
    {
        "title": 'Урок 5: Вложенные условия (`иначе если`)',
        "instruction": 'Используйте `иначе если` для проверки нескольких условий по очереди. Проверьте число: если оно больше 10, выведите "Больше 10"; иначе если оно равно 10, выведите "Равно 10".\n\nТеория: `иначе если` позволяет создать цепочку проверок. Программа проверяет условия одно за другим и выполняет блок кода, соответствующий первому истинному условию.',
        "example": 'Пример: `установить оценка в 4\nесли оценка == 5 тогда\n    вывести "Отлично"\nиначе если оценка == 4 тогда\n    вывести "Хорошо"\nконец`',
        "homework": 'Домашнее задание: Напишите программу, которая проверяет число: если оно положительное, выводит "Положительное", если отрицательное — "Отрицательное", а если равно нулю — "Ноль".',
        "code": 'установить число в 10\nесли число > 10 тогда\n    вывести "Больше 10"\nиначе если число == 10 тогда\n    вывести "Равно 10"\nконец',
        "expectedOutput": 'Равно 10\n',
    },
    {
        "title": 'Урок 6: Ветвление с `иначе`',
        "instruction": 'Добавьте блок `иначе` к условию. Если возраст меньше 18, выведите "Несовершеннолетний.".\n\nТеория: Блок `иначе` выполняется, если условие в `если` оказалось ложным. Это гарантирует, что один из двух блоков кода будет выполнен в любом случае.',
        "example": 'Пример: `установить пароль в "wrong"\nесли пароль == "12345" тогда\n    вывести "Доступ разрешен"\nиначе:\n    вывести "Доступ запрещен"\nконец`',
        "homework": 'Домашнее задание: Проверьте, является ли число четным. Если да, выведите "Четное", иначе выведите "Нечетное". (Подсказка: используйте оператор остатка от деления `%`).',
        "code": 'установить возраст в 16\nесли возраст >= 18 тогда\n    вывести "Совершеннолетний."\nиначе:\n    вывести "Несовершеннолетний."\nконец',
        "expectedOutput": 'Несовершеннолетний.\n',
    },
    {
        "title": 'Урок 7: Цикл "повторять"',
        "instruction": 'Используйте `повторять 3 раз: ... конец`, чтобы вывести строку "Цикл" три раза.\n\nТеория: Циклы нужны для многократного выполнения одного и того же блока кода. Цикл `повторять` выполняет код указанное количество раз, что удобно, когда число повторений известно заранее.',
        "example": 'Пример: `повторять 5 раз:\n    вывести i\nконец` выведет числа от 0 до 4. Переменная `i` автоматически создается и увеличивается на каждой итерации.',
        "homework": 'Домашнее задание: Используя цикл `повторять`, напишите программу, которая вычисляет сумму чисел от 1 до 5 (1+2+3+4+5).',
        "code": 'повторять 3 раз:\n    вывести "Цикл"\nконец',
        "expectedOutput": 'Цикл\nЦикл\nЦикл\n',
    },
    {
        "title": 'Урок 8: Прерывание цикла (`прервать`)',
        "instruction": 'Иногда нужно выйти из цикла до его завершения. Используйте `прервать`. Выведите числа от 0 до 9, но прервите цикл, если число равно 5.\n\nТеория: Команда `прервать` немедленно прекращает выполнение цикла, в котором она находится. Выполнение программы продолжается со следующей строки после блока цикла.',
        "example": 'Пример поиска первого пользователя с именем "Анна": `для каждого пользователь в список_пользователей:\n    если пользователь == "Анна" тогда\n        вывести "Анна найдена!"\n        прервать\n    конец\nконец`',
        "homework": 'Домашнее задание: Напишите программу, которая бесконечно запрашивает у пользователя ввод (симуляция), пока он не введет слово "выход".',
        "code": 'повторять 10 раз:\n    если i == 5 тогда\n        прервать\n    конец\n    вывести i\nконец',
        "expectedOutput": '0\n1\n2\n3\n4\n',
    },
    {
        "title": 'Урок 9: Пропуск итерации (`продолжить`)',
        "instruction": 'Используйте `продолжить`, чтобы пропустить текущую итерацию и перейти к следующей. Выведите числа от 0 до 4, пропуская число 2.\n\nТеория: Команда `продолжить` прекращает текущий проход цикла и немедленно переходит к следующему. Код после `продолжить` в текущей итерации не выполняется.',
        "example": 'Пример вывода только нечетных чисел: `повторять 10 раз:\n    если i % 2 == 0 тогда\n        продолжить\n    конец\n    вывести i\nконец`',
        "homework": 'Домашнее задание: Дан список чисел `[10, -5, 20, 0, -8, 15]`. Напишите программу, которая выводит только положительные числа из этого списка, используя `продолжить` для пропуска отрицательных чисел и нуля.',
        "code": 'повторять 5 раз:\n    если i == 2 тогда\n        продолжить\n    конец\n    вывести i\nконец',
        "expectedOutput": '0\n1\n3\n4\n',
    },
    {
        "title": 'Урок 10: Логические операторы',
        "instruction": 'Используйте `если` и `и` для проверки двух условий. Установите `число` в `15`. Проверьте, если `число > 10` и `число < 20`, выведите "Число находится в диапазоне".\n\nТеория: Логические операторы (`и`, `или`) позволяют комбинировать несколько условий. Оператор `и` вернет истину, только если оба условия истинны.',
        "example": 'Пример с оператором `или`: `установить день в "суббота"\nесли день == "суббота" или день == "воскресенье" тогда\n    вывести "Выходной!"\nконец`',
        "homework": 'Домашнее задание: Создайте переменные `логин` и `пароль`. Напишите программу, которая выводит "Доступ разрешен", только если `логин` равен "admin" И `пароль` равен "12345".',
        "code": 'установить число в 15\nесли число > 10 и число < 20 тогда\n    вывести "Число находится в диапазоне"\nконец',
        "expectedOutput": 'Число находится в диапазоне\n',
    },
    {
        "title": 'Урок 11: Цикл "пока"',
        "instruction": 'Используйте `пока`, чтобы повторять действие, пока условие истинно. Установите `счетчик` в `0`. Пока `счетчик < 3`, выводите `счетчик` и увеличивайте его на 1.\n\nТеория: Цикл `пока` выполняется до тех пор, пока его условие истинно. Это полезно, когда точное количество итераций неизвестно. Важно изменять переменную условия внутри цикла, чтобы избежать "бесконечного цикла".',
        "example": 'Пример обратного отсчета: `установить число в 5\nпока число > 0 тогда\n    вывести число\n    изменить число в число - 1\nконец`',
        "homework": 'Домашнее задание: Напишите программу с циклом `пока`, которая выводит степени двойки (1, 2, 4, 8, 16, ...), пока число меньше 100.',
        "code": 'установить счетчик в 0\nпока счетчик < 3 тогда\n    вывести счетчик\n    изменить счетчик в счетчик + 1\nконец',
        "expectedOutput": '0\n1\n2\n',
    },
    {
        "title": 'Урок 12: Длина строки',
        "instruction": 'Узнайте длину строки с помощью `длина()`. Создайте строку "привет" и выведите ее длину.\n\nТеория: `длина()` — это встроенная функция, которая возвращает количество символов в строке. Это полезно для множества задач, например, для ограничения вводимых пользователем данных.',
        "example": 'Пример: `длина("")` вернет 0, так как пустая строка не содержит символов.',
        "homework": 'Домашнее задание: Создайте переменную, хранящую ваше полное имя (имя и фамилию). Выведите на экран, сколько букв в вашем полном имени.',
        "code": 'установить моя_строка в "привет"\nвывести длина(моя_строка)',
        "expectedOutput": '6\n',
    },
    {
        "title": 'Урок 13: Срезы строк',
        "instruction": 'Из строк можно извлекать части (срезы). Синтаксис `строка[начало:конец]` позволяет это сделать. Возьмите строку "программирование" и выведите срез с 3-го по 7-й символ.\n\nТеория: Срезы — это мощный инструмент для работы с последовательностями. Индекс `начало` включается в срез, а `конец` — нет. Нумерация символов начинается с 0.',
        "example": 'Пример получения первых 3 символов: `слово[0:3]` или просто `слово[:3]`. Пример получения всех символов, кроме первого: `слово[1:]`.',
        "homework": 'Домашнее задание: Дана строка `дата = "2023-10-26"`. Используя срезы, извлеките и выведите отдельно год, месяц и день.',
        "code": 'установить слово в "программирование"\nвывести слово[3:7]',
        "expectedOutput": 'грам\n',
    },
    {
        "title": 'Урок 14: Форматирование строк (ф-строки)',
        "instruction": 'Форматирование строк позволяет вставлять значения переменных прямо в строку. Создайте переменную `имя` и выведите приветствие.\n\nТеория: ф-строки (начинаются с `ф""`) — это современный и удобный способ форматирования. Просто укажите имя переменной в фигурных скобках `{}` внутри строки.',
        "example": 'Пример с несколькими переменными: `установить товар в "кофе"\nустановить цена в 150\nвывести ф"{товар} стоит {цена} рублей."`',
        "homework": 'Домашнее задание: Создайте переменные `ширина` и `высота` со значениями 10 и 5. Выведите строку: "Прямоугольник размером 10x5 имеет площадь 50.", вычислив площадь прямо внутри ф-строки.',
        "code": 'установить имя в "Алиса"\nвывести ф"Привет, {имя}!"',
        "expectedOutput": 'Привет, Алиса!\n',
    },
    # --- Блок 2: Структуры данных (Уроки 15-25) ---
    {
        "title": 'Урок 15: Списки (Массивы)',
        "instruction": 'Создайте список фруктов: "яблоко", "банан", "апельсин".\n\nТеория: Список — это упорядоченная, изменяемая коллекция элементов. Элементы могут быть разных типов. Списки объявляются в квадратных скобках `[]`.',
        "example": 'Пример списка с разными типами данных: `установить разное в ["текст", 123, истина]`',
        "homework": 'Домашнее задание: Создайте список ваших любимых хобби. Список должен содержать как минимум три элемента. Выведите весь список на экран.',
        "code": 'установить список_фруктов в ["яблоко", "банан", "апельсин"]\nвывести список_фруктов',
        "expectedOutput": "['яблоко', 'банан', 'апельсин']\n",
    },
    {
        "title": 'Урок 16: Добавление в список',
        "instruction": 'Используйте `добавить`, чтобы положить "киви" в конец списка фруктов.\n\nТеория: Метод `добавить` изменяет исходный список, добавляя новый элемент в его конец. Это одна из самых частых операций со списками.',
        "example": 'Пример добавления числа в список: `установить числа в [1, 2]\nдобавить 3 в числа`',
        "homework": 'Домашнее задание: Создайте пустой список `дела`. Затем добавьте в него три дела, которые вам нужно сегодня сделать, и выведите итоговый список.',
        "code": 'установить список_фруктов в ["яблоко", "банан"]\nдобавить "киви" в список_фруктов\nвывести список_фруктов',
        "expectedOutput": "['яблоко', 'банан', 'киви']\n",
    },
    {
        "title": 'Урок 17: Удаление из списка',
        "instruction": 'Используйте `удалить` для удаления элемента по его индексу. Удалите второй элемент ("банан") из списка.\n\nТеория: Команда `удалить` позволяет убрать элемент из списка по его номеру (индексу). Помните, что нумерация начинается с 0.',
        "example": 'Пример удаления первого элемента: `установить числа в [10, 20, 30]\nудалить числа[0]`',
        "homework": 'Домашнее задание: Создайте список `[1, 2, 3, 4, 5]`. Удалите из него последний элемент. Подсказка: как можно узнать индекс последнего элемента, зная длину списка?',
        "code": 'установить список_фруктов в ["яблоко", "банан", "апельсин"]\nудалить список_фруктов[1]\nвывести список_фруктов',
        "expectedOutput": "['яблоко', 'апельсин']\n",
    },
    {
        "title": 'Урок 18: Цикл "для каждого"',
        "instruction": 'Используйте цикл `для каждого ... в ...` чтобы перебрать все элементы списка и вывести каждый на новой строке.\n\nТеория: Этот тип цикла идеально подходит для работы с коллекциями (списками, строками и др.). Он последовательно присваивает переменной значение каждого элемента коллекции.',
        "example": 'Пример перебора строки: `для каждого буква в "привет":\n    вывести буква\nконец`',
        "homework": 'Домашнее задание: Создайте список чисел `[1, 2, 3, 4, 5]`. Используя цикл, выведите квадрат каждого числа.',
        "code": 'установить список_фруктов в ["яблоко", "банан"]\nдля каждого фрукт в список_фруктов:\n    вывести фрукт\nконец',
        "expectedOutput": 'яблоко\nбанан\n',
    },
    {
        "title": 'Урок 19: Проверка наличия элемента',
        "instruction": 'Проверьте, содержится ли "банан" в вашем списке фруктов, используя оператор `содержит`.\n\nТеория: Оператор `содержит` возвращает "истину", если элемент присутствует в коллекции, и "ложь" в противном случае. Это очень удобный способ для проверки.',
        "example": 'Пример: `если "кот" содержит "о" тогда ...` вернет "истину".',
        "homework": 'Домашнее задание: Создайте список запрещенных слов. Затем создайте переменную с предложением. Напишите программу, которая проверяет, содержит ли предложение хотя бы одно запрещенное слово.',
        "code": 'установить список_фруктов в ["яблоко", "банан", "апельсин"]\nесли список_фруктов содержит "банан" тогда\n    вывести "Да, банан в списке!"\nконец',
        "expectedOutput": 'Да, банан в списке!\n',
    },
    {
        "title": 'Урок 20: Словари (Объекты)',
        "instruction": 'Создайте словарь с парами ключ-значение: "имя": "Иван" и "возраст": 30. Затем выведите значение по ключу "имя".\n\nТеория: Словарь — это неупорядоченная коллекция пар `ключ: значение`. Ключи должны быть уникальными. Словари объявляются в фигурных скобках `{}`. Доступ к значению осуществляется по ключу.',
        "example": 'Пример словаря с ценами: `установить цены в {"хлеб": 50, "молоко": 80}`. Доступ к цене молока: `цены["молоко"]`.',
        "homework": 'Домашнее задание: Создайте словарь, представляющий контакт в телефонной книге. Он должен содержать ключи "имя", "фамилия" и "телефон". Заполните его данными и выведите на экран телефон.',
        "code": 'установить мой_словарь в {"имя": "Иван", "возраст": 30}\nвывести мой_словарь["имя"]',
        "expectedOutput": 'Иван\n',
    },
    {
        "title": 'Урок 21: Добавление в словарь',
        "instruction": 'Добавьте в словарь новую пару "город": "Москва" и выведите весь словарь.\n\nТеория: Добавление или изменение элемента в словаре происходит путем присваивания значения по ключу. Если ключ уже существует, его значение обновится. Если нет — будет создана новая пара.',
        "example": 'Пример изменения цены: `изменить цены["хлеб"] в 55`',
        "homework": 'Домашнее задание: Создайте пустой словарь `пользователь`. Затем поочередно добавьте в него ключи `id`, `имя_пользователя` и `статус` с соответствующими значениями. Выведите итоговый словарь.',
        "code": 'установить мой_словарь в {"имя": "Иван"}\nизменить мой_словарь["город"] в "Москва"\nвывести мой_словарь',
        "expectedOutput": '{\'имя\': "Иван", \'город\': "Москва"}\n',
    },
    {
        "title": 'Урок 22: Удаление из словаря',
        "instruction": 'Удалите пару с ключом "возраст" из словаря.\n\nТеория: Как и в списках, команда `удалить` используется для удаления элемента. В словарях она удаляет пару по указанному ключу.',
        "example": 'Пример: `удалить цены["молоко"]`',
        "homework": 'Домашнее задание: Создайте словарь с несколькими настройками. Затем удалите из него одну настройку (например, `уведомления_включены`) и выведите оставшиеся.',
        "code": 'установить мой_словарь в {"имя": "Иван", "возраст": 30}\nудалить мой_словарь["возраст"]\nвывести мой_словарь',
        "expectedOutput": "{'имя': 'Иван'}\n",
    },
    {
        "title": 'Урок 23: Кортежи',
        "instruction": 'Создайте кортеж `мои_данные` со значениями `("Алекс", 25)` и выведите второй элемент.\n\nТеория: Кортежи похожи на списки, но они неизменяемы. Это значит, что после создания их нельзя изменить. Они создаются с помощью круглых скобок `()` или просто перечислением через запятую.',
        "example": 'Пример: `установить координаты в (10, 20)`',
        "homework": 'Домашнее задание: Создайте кортеж, хранящий цвета радуги. Попробуйте изменить один из цветов. Какую ошибку вы ожидаете увидеть?',
        "code": 'установить мои_данные в ("Алекс", 25)\nвывести мои_данные[1]',
        "expectedOutput": '25\n',
    },
    {
        "title": 'Урок 24: Множества',
        "instruction": 'Создайте множество из списка с повторяющимися элементами и посмотрите, что получится.\n\nТеория: Множество — это неупорядоченная коллекция уникальных элементов. Оно автоматически удаляет все дубликаты. Множества очень быстры для проверки наличия элемента.',
        "example": 'Пример: `установить буквы в множество("привет мир")`. Множество будет содержать только уникальные буквы из этой строки.',
        "homework": 'Домашнее задание: У вас есть два списка тегов для статей: `[ "python", "код", "программирование" ]` и `[ "python", "данные", "анализ" ]`. Найдите общие теги для обоих списков, используя множества.',
        "code": 'установить мой_список в [1, 2, 2, 3, 3, 3]\nустановить мое_множество в множество(мой_список)\nвывести мое_множество',
        "expectedOutput": '{1, 2, 3}\n',
    },
    {
        "title": 'Урок 25: Генераторы списков',
        "instruction": 'Создайте список квадратов чисел от 0 до 4 с помощью генератора.\n\nТеория: Генераторы списков — это краткий и элегантный способ создания списков. Синтаксис: `[выражение для элемент в исходный_список]`. Это более "продвинутый", но очень мощный инструмент.',
        "example": 'Пример создания списка имен в верхнем регистре: `установить имена в ["анна", "иван"]\nустановить верхний_регистр в [имя.вверх() для имя в имена]`',
        "homework": 'Домашнее задание: Дан список `[1, 2, 3, 4, 5, 6]`. Используя генератор списков, создайте новый список, содержащий только четные числа из исходного.',
        "code": 'установить квадраты в [x*x для x в диапазон(5)]\nвывести квадраты',
        "expectedOutput": '[0, 1, 4, 9, 16]\n',
    },
    # --- Блок 3: Функции и ООП (Уроки 26-34) ---
    {
        "title": 'Урок 26: Функции',
        "instruction": 'Создайте функцию `приветствие`, которая принимает `имя` и выводит приветствие.\n\nТеория: Функции — это именованные блоки кода, которые можно вызывать многократно. Они помогают избегать повторения кода и делают программу более структурированной. Аргументы — это данные, которые передаются в функцию для работы.',
        "example": 'Пример функции, которая выводит квадрат числа: `определить показать_квадрат(число):\n    вывести число * число\nконец`',
        "homework": 'Домашнее задание: Напишите функцию `прощание`, которая не принимает аргументов и выводит на экран "До свидания!". Вызовите ее.',
        "code": 'определить приветствие(имя):\n    вывести ф"Привет, {имя}!"\nконец\n\nприветствие("Анна")',
        "expectedOutput": 'Привет, Анна!\n',
    },
    {
        "title": 'Урок 27: Возврат значения из функции',
        "instruction": 'Создайте функцию `умножить_на_два`, которая принимает `x` и `возвращает` результат `x * 2`.\n\nТеория: Команда `вернуть` не только завершает выполнение функции, но и отправляет результат обратно в то место, откуда функция была вызвана. Этот результат можно присвоить переменной.',
        "example": 'Пример функции, которая возвращает, является ли число четным: `определить это_четное(число):\n    вернуть число % 2 == 0\nконец`',
        "homework": 'Домашнее задание: Напишите функцию `площадь_прямоугольника`, которая принимает `ширину` и `высоту` и возвращает их произведение.',
        "code": 'определить умножить_на_два(x):\n    вернуть x * 2\nконец\n\nустановить результат в умножить_на_два(5)\nвывести результат',
        "expectedOutput": '10\n',
    },
    {
        "title": 'Урок 28: Аргументы по умолчанию',
        "instruction": 'Создайте функцию `приветствие` с необязательным аргументом `имя`, значение по умолчанию которого "незнакомец".\n\nТеория: Аргументы по умолчанию позволяют вызывать функцию, не передавая для них значения. Если значение не передано, используется значение по умолчанию.',
        "example": 'Пример: `определить создать_пользователя(имя, статус="активен"):\n    ...\nконец`. Теперь можно вызывать `создать_пользователя("Иван")`, и статус будет "активен".',
        "homework": 'Домашнее задание: Напишите функцию `повторить_строку`, которая принимает `строку` и `количество` (по умолчанию 3) и выводит строку указанное количество раз.',
        "code": 'определить приветствие(имя="незнакомец"):\n    вывести ф"Привет, {имя}!"\nконец\n\nприветствие()\nприветствие("Иван")',
        "expectedOutput": 'Привет, незнакомец!\nПривет, Иван!\n',
    },
    {
        "title": 'Урок 29: Рекурсия',
        "instruction": 'Напишите рекурсивную функцию `факториал`.\n\nТеория: Рекурсия — это когда функция вызывает саму себя. Для рекурсии критически важно иметь "базовый случай" — условие, при котором вызовы прекращаются, чтобы избежать бесконечного цикла.',
        "example": 'Пример рекурсивной функции для обратного отсчета: `определить отсчет(n):\n    если n < 0 тогда\n        вернуть\n    иначе:\n        вывести n\n        отсчет(n - 1)\n    конец\nконец`',
        "homework": 'Домашнее задание: Напишите рекурсивную функцию для вычисления суммы чисел от 1 до N.',
        "code": 'определить факториал(n):\n    если n < 2 тогда\n        вернуть 1\n    иначе:\n        вернуть n * факториал(n - 1)\n    конец\nконец\n\nвывести факториал(4)',
        "expectedOutput": '24\n'
    },
    {
        "title": 'Урок 30: Лямбда-функции',
        "instruction": 'Создайте лямбда-функцию для сложения двух чисел и сразу же вызовите ее.\n\nТеория: Лямбда-функции — это небольшие анонимные функции. Они полезны, когда нужна простая функция на короткое время, например, для сортировки.',
        "example": 'Пример лямбда-функции для возведения в квадрат: `установить квадрат в лямбда x: x * x\nвывести квадрат(4)`',
        "homework": 'Домашнее задание: У вас есть список пар `[("банан", 5), ("яблоко", 2)]`. Отсортируйте его по второму элементу каждой пары, используя лямбда-функцию.',
        "code": 'установить сумма в лямбда a, b: a + b\nвывести сумма(5, 3)',
        "expectedOutput": '8\n',
    },
    {
        "title": 'Урок 31: Классы и Объекты',
        "instruction": 'Создайте простой класс `Собака` и создайте его экземпляр (объект) по кличке "Рекс".\n\nТеория: Класс — это "чертеж" для создания объектов. Объект — это конкретный экземпляр класса со своими собственными данными. `__init__` — это специальный метод-конструктор, который вызывается при создании нового объекта.',
        "example": 'Пример класса `Кот`: `определить класс Кот:\n    определить __init__(имя, возраст):\n        это.имя в имя\n        это.возраст в возраст\n    конец\nконец`',
        "homework": 'Домашнее задание: Создайте класс `Машина` с атрибутами `марка`, `модель` и `год`. Создайте экземпляр этого класса, представляющий вашу любимую машину.',
        "code": 'определить класс Собака:\n    определить __init__(имя):\n        это.имя в имя\n    конец\nконец\n\nустановить рекс в новый Собака("Рекс")\nвывести рекс.имя',
        "expectedOutput": 'Рекс\n',
    },
    {
        "title": 'Урок 32: Методы объекта',
        "instruction": 'Добавьте в класс `Собака` метод `лай`, который выводит "{имя} говорит: Гав!".\n\nТеория: Методы — это функции, которые принадлежат классу. Они могут работать с данными объекта (его атрибутами). Ключевое слово `это` (self в Python) ссылается на сам экземпляр объекта.',
        "example": 'Пример метода для класса `Кот`: `определить мяукать():\n    вывести это.имя + " говорит: Мяу!"\nконец`',
        "homework": 'Домашнее задание: Добавьте в ваш класс `Машина` метод `показать_инфо`, который выводит всю информацию о машине в читаемом виде.',
        "code": 'определить класс Собака:\n    определить __init__(имя):\n        это.имя в имя\n    конец\n\n    определить лай():\n        вывести ф"{это.имя} говорит: Гав!"\n    конец\nконец\n\nустановить рекс в новый Собака("Рекс")\nрекс.лай()',
        "expectedOutput": 'Рекс говорит: Гав!\n',
    },
    {
        "title": 'Урок 33: Наследование',
        "instruction": 'Создайте класс `Пудель`, который наследует от `Собака` и добавляет метод `трюк`.\n\nТеория: Наследование позволяет новому классу (потомку) перенимать все атрибуты и методы существующего класса (родителя). Это способствует повторному использованию кода.',
        "example": 'Пример: `определить класс Сиамский наследует Кот: ... конец`. Теперь Сиамский кот тоже умеет мяукать.',
        "homework": 'Домашнее задание: Создайте класс `Электромобиль`, который наследует от вашего класса `Машина`. Добавьте ему новый атрибут `емкость_батареи` и метод `зарядить`.',
        "code": 'определить класс Собака:\n    определить __init__(имя):\n        это.имя в имя\n    конец\n    определить лай():\n        вывести ф"{это.имя} говорит: Гав!"\n    конец\nконец\n\nопределить класс Пудель наследует Собака:\n    определить трюк():\n        вывести ф"{это.имя} делает сальто!"\n    конец\nконец\n\nустановить арчи в новый Пудель("Арчи")\nарчи.лай()\nарчи.трюк()',
        "expectedOutput": 'Арчи говорит: Гав!\nАрчи делает сальто!\n',
    },
    {
        "title": 'Урок 34: Переменные класса',
        "instruction": 'Добавьте в класс `Собака` переменную класса `вид` со значением "млекопитающее" и выведите ее через экземпляр класса.\n\nТеория: Переменные класса принадлежат самому классу, а не его экземплярам. Все экземпляры класса имеют доступ к одной и той же переменной класса.',
        "example": 'Пример счетчика объектов: `определить класс Пользователь:\n    количество в 0\n    определить __init__():\n        изменить Пользователь.количество в Пользователь.количество + 1\n    конец\nконец`',
        "homework": 'Домашнее задание: В классе `Машина` создайте переменную класса `количество_машин`, которая будет увеличиваться каждый раз, когда создается новый объект-машина.',
        "code": 'определить класс Собака:\n    вид в "млекопитающее"\n    определить __init__(имя):\n        это.имя в имя\n    конец\nконец\n\nустановить рекс в новый Собака("Рекс")\nвывести рекс.вид',
        "expectedOutput": 'млекопитающее\n',
    },
    # --- Блок 4: Файлы, Модули и Ошибки (Уроки 35-42) ---
    {
        "title": 'Урок 35: Запись в файл',
        "instruction": 'Запишите строку "Первая строка." в (симулированный) файл с именем "мой_файл.txt".\n\nТеория: Работа с файлами — основа для сохранения данных между запусками программы. Сначала файл нужно `открыть` в режиме записи (`для записи`), затем `записать` в него данные и `закрыть` (с помощью блока `конец`).',
        "example": 'Пример записи нескольких строк: `файл.записать("Строка 1\\nСтрока 2")` (`\\n` — это символ новой строки).',
        "homework": 'Домашнее задание: Создайте список покупок (как в предыдущих уроках). Напишите программу, которая записывает каждый элемент списка на новой строке в файл "покупки.txt".',
        "code": 'открыть "мой_файл.txt" для записи как файл:\n    файл.записать("Первая строка.")\nконец\nвывести "Файл записан."',
        "expectedOutput": 'Файл записан.\n',
    },
    {
        "title": 'Урок 36: Чтение из файла',
        "instruction": 'Прочитайте содержимое файла "мой_файл.txt", который вы создали на предыдущем уроке.\n\nТеория: Чтобы прочитать данные, файл нужно `открыть` в режиме чтения (`для чтения`). Метод `прочитать()` считывает всё содержимое файла в одну строку.',
        "example": 'Чтение файла построчно: `для каждого строка в файл:\n    вывести строка\nконец`',
        "homework": 'Домашнее задание: Прочитайте созданный вами файл "покупки.txt" и выведите его содержимое на экран.',
        "code": 'открыть "мой_файл.txt" для записи как файл:\n    файл.записать("Привет из файла!")\nконец\nоткрыть "мой_файл.txt" для чтения как файл:\n    установить содержимое в файл.прочитать()\n    вывести содержимое\nконец',
        "expectedOutput": 'Привет из файла!\n',
    },
    {
        "title": 'Урок 37: Обработка исключений (`попытаться / поймать`)',
        "instruction": 'Используйте `попытаться`, чтобы выполнить деление на ноль, и `поймать`, чтобы обработать ошибку.\n\nТеория: Эта конструкция позволяет программе "изящно" обрабатывать ошибки, не прерывая свою работу. Код, который может вызвать ошибку, помещается в блок `попытаться`. Код для обработки ошибки — в блок `поймать`.',
        "example": 'Пример обработки ошибки при доступе к словарю: `попытаться:\n    вывести мой_словарь["несуществующий_ключ"]\nпоймать:\n    вывести "Такого ключа нет!"\nконец`',
        "homework": 'Домашнее задание: Напишите программу, которая просит пользователя ввести число. Используйте `попытаться/поймать`, чтобы обработать случай, когда пользователь вводит не число, а текст.',
        "code": 'попытаться:\n    установить результат в 10 / 0\nпоймать:\n    вывести "Ошибка: деление на ноль!"\nконец',
        "expectedOutput": 'Ошибка: деление на ноль!\n',
    },
    {
        "title": 'Урок 38: Блок `наконец`',
        "instruction": 'Добавьте блок `наконец`, который выполняется всегда, независимо от того, была ли ошибка.\n\nТеория: Блок `наконец` (finally в Python) идеально подходит для кода, который должен выполниться в любом случае, например, для закрытия файлов или сетевых соединений.',
        "example": 'Пример с файлом: `попытаться:\n    # работа с файлом\nпоймать:\n    # обработка ошибки\nнаконец:\n    # закрытие файла\nконец`',
        "homework": 'Домашнее задание: Смоделируйте подключение к базе данных. В блоке `попытаться` выведите "Работа с данными...", в блоке `поймать` — "Ошибка данных", а в блоке `наконец` — "Соединение закрыто".',
        "code": 'попытаться:\n    установить результат в 10 / 2\n    вывести "Деление успешно"\nпоймать:\n    вывести "Произошла ошибка."\nнаконец:\n    вывести "Блок `наконец` выполнен."\nконец',
        "expectedOutput": 'Деление успешно\nБлок `наконец` выполнен.\n',
    },
    {
        "title": 'Урок 39: Модули',
        "instruction": 'Импортируйте симулированный модуль `Математика` и воспользуйтесь его константой `пи`.\n\nТеория: Модули — это файлы с кодом, которые можно подключать к своей программе, чтобы использовать готовые функции и переменные. Это помогает организовывать код и повторно его использовать.',
        "example": 'Пример: `импорт Случайный\nвывести Случайный.число(1, 10)`',
        "homework": 'Домашнее задание: Импортируйте модуль `Время` и выведите текущую дату и время.',
        "code": 'импорт Математика\nвывести Математика.пи',
        "expectedOutput": f'{math.pi}\n',
    },
    {
        "title": 'Урок 40: Работа с JSON',
        "instruction": 'Преобразуйте словарь в строку формата JSON.\n\nТеория: JSON (JavaScript Object Notation) — это текстовый формат для обмена данными. Он легко читается и людьми, и машинами. В нашем языке есть модуль `джейсон` для работы с ним.',
        "example": 'Пример: `джейсон.загрузить(\'{"ключ": "значение"}\')` преобразует строку в словарь.',
        "homework": 'Домашнее задание: Создайте сложный словарь (с вложенными списками и другими словарями) и преобразуйте его в красивую JSON-строку с отступами.',
        "code": 'импорт джейсон\nустановить данные в {"имя": "Иван", "возраст": 30, "города": ["Москва", "Киев"]}\nустановить json_строка в джейсон.выгрузить(данные)\nвывести json_строка',
        "expectedOutput": '{"имя": "Иван", "возраст": 30, "города": ["Москва", "Киев"]}\n',
    },
    {
        "title": 'Урок 41: Симуляция API',
        "instruction": 'Сделайте симулированный веб-запрос, чтобы получить "данные" из сети.\n\nТеория: API (Application Programming Interface) — это способ, которым программы общаются друг с другом. Часто данные получают через веб-запросы. Модуль `веб` симулирует это поведение.',
        "example": 'Пример: `веб.запрос("https://api.example.com/user/1")`',
        "homework": 'Домашнее задание: Сделайте запрос на получение "списка постов". Результат будет в формате JSON. Преобразуйте его в словарь и выведите заголовок первого поста.',
        "code": 'импорт веб\nимпорт джейсон\nустановить ответ в веб.запрос("https://api.example.com/data")\nустановить данные в джейсон.загрузить(ответ)\nвывести данные["сообщение"]',
        "expectedOutput": 'Успех!\n',
    },
    {
        "title": 'Урок 42: Дата и время',
        "instruction": 'Получите текущее время и отформатируйте его в виде "ГГГГ-ММ-ДД".\n\nТеория: Модуль `время` предоставляет инструменты для работы с датами и временем. Можно получить текущий момент, а также отформатировать его в любой удобный вид.',
        "example": 'Пример: `время.формат(время.сейчас(), "%H:%M:%S")` выведет текущее время.',
        "homework": 'Домашнее задание: Узнайте, какой день недели был в день вашего рождения.',
        "code": 'импорт время\nустановить сейчас в время.сейчас()\nвывести время.формат(сейчас, "%Y-%m-%d")',
        "expectedOutput": f'{datetime.datetime.now().strftime("%Y-%m-%d")}\n',
    },
    # --- Блок 5: Продвинутые темы (Уроки 43-51) ---
    {
        "title": 'Урок 43: Продвинутые списки',
        "instruction": 'Отсортируйте список чисел по возрастанию.\n\nТеория: У списков есть полезные встроенные методы. `сортировать()` изменяет список на месте, упорядочивая его. `перевернуть()` меняет порядок элементов на обратный.',
        "example": 'Пример: `числа.перевернуть()`',
        "homework": 'Домашнее задание: Создайте список строк. Отсортируйте его по алфавиту, а затем переверните, чтобы порядок стал обратным алфавитному.',
        "code": 'установить числа в [3, 1, 4, 1, 5, 9, 2]\nчисла.сортировать()\nвывести числа',
        "expectedOutput": '[1, 1, 2, 3, 4, 5, 9]\n',
    },
    {
        "title": 'Урок 44: Продвинутые словари',
        "instruction": 'Получите все ключи из словаря и выведите их как список.\n\nТеория: Словари позволяют получать отдельно списки ключей, значений или пар (ключ, значение) с помощью методов `ключи()`, `значения()` и `элементы()`.',
        "example": 'Пример: `для каждого ключ, значение в мой_словарь.элементы(): ...`',
        "homework": 'Домашнее задание: Создайте словарь с ценами на товары. Посчитайте общую сумму всех цен, используя метод `значения()`.',
        "code": 'установить пользователь в {"имя": "Анна", "возраст": 28, "статус": "активен"}\nустановить ключи в список(пользователь.ключи())\nвывести ключи',
        "expectedOutput": "['имя', 'возраст', 'статус']\n",
    },
    {
        "title": 'Урок 45: Продвинутые строки',
        "instruction": 'Преобразуйте строку в верхний регистр.\n\nТеория: Строки имеют множество методов для их преобразования: `вверх()`, `вниз()`, `заменить(старое, новое)`, `разделить(символ)`.',
        "example": 'Пример: `вывести "привет, мир".заменить("мир", "Python")`',
        "homework": 'Домашнее задание: Дана строка "яблоко,банан,апельсин". Используя метод `разделить()`, преобразуйте ее в список фруктов.',
        "code": 'установить фраза в "Всем привет!"\nвывести фраза.вверх()',
        "expectedOutput": 'ВСЕМ ПРИВЕТ!\n',
    },
    {
        "title": 'Урок 46: Математические функции',
        "instruction": 'Найдите квадратный корень из 81 с помощью модуля `Математика`.\n\nТеория: Модуль `Математика` содержит множество полезных математических функций, таких как `корень()`, `синус()`, `косинус()`, `степень(число, степень)`.',
        "example": 'Пример: `Математика.степень(2, 3)` вернет 8.',
        "homework": 'Домашнее задание: Вычислите гипотенузу прямоугольного треугольника с катетами 3 и 4. Формула: c = корень(a*a + b*b).',
        "code": 'импорт Математика\nвывести Математика.корень(81)',
        "expectedOutput": '9.0\n',
    },
    {
        "title": 'Урок 47: Случайные числа',
        "instruction": 'Сгенерируйте случайное целое число от 1 до 100.\n\nТеория: Модуль `Случайный` позволяет вносить в программу элемент случайности. `число(a, b)` генерирует целое число, а `выбор(список)` выбирает случайный элемент из списка.',
        "example": 'Пример: `Случайный.выбор(["орел", "решка"])`',
        "homework": 'Домашнее задание: Создайте программу, которая имитирует бросок игральной кости (выдает случайное число от 1 до 6).',
        "code": 'импорт Случайный\nустановить мое_число в Случайный.число(1, 100)\nвывести мое_число >= 1 и мое_число <= 100',
        "expectedOutput": 'истина\n',
    },
    {
        "title": 'Урок 48: Полиморфизм',
        "instruction": 'Создайте два разных класса с одинаковым методом и вызовите его для объектов обоих классов.\n\nТеория: Полиморфизм — это способность объектов с разным типом отвечать на один и тот же вызов метода. Например, и кошка, и собака могут "издавать звук", но делают это по-разному.',
        "example": 'См. код урока.',
        "homework": 'Домашнее задание: Создайте классы `Круг` и `Квадрат`. У обоих должен быть метод `площадь()`, который вычисляет и возвращает площадь соответствующей фигуры.',
        "code": 'определить класс Кот:\n    определить издать_звук():\n        вывести "Мяу"\n    конец\nконец\nопределить класс Собака:\n    определить издать_звук():\n        вывести "Гав"\n    конец\nконец\n\nустановить животные в [новый Кот(), новый Собака()]\nдля каждого животное в животные:\n    животное.издать_звук()\nконец',
        "expectedOutput": 'Мяу\nГав\n',
    },
    {
        "title": 'Урок 49: Инкапсуляция',
        "instruction": 'Создайте "приватный" атрибут и метод для доступа к нему.\n\nТеория: Инкапсуляция — это сокрытие внутренней реализации объекта. Хотя в нашем языке нет строгой приватности, мы можем симулировать ее, договорившись, что атрибуты, начинающиеся с `_`, являются внутренними.',
        "example": 'См. код урока.',
        "homework": 'Домашнее задание: В классе `СчетВБанке` создайте приватный атрибут `_баланс`. Создайте публичные методы `пополнить(сумма)` и `снять(сумма)`, которые изменяют баланс, и метод `получить_баланс()`, который его возвращает.',
        "code": 'определить класс Человек:\n    определить __init__(имя, возраст):\n        это.имя в имя\n        это._возраст в возраст\n    конец\n    определить получить_возраст():\n        вернуть это._возраст\n    конец\nконец\n\nустановить иван в новый Человек("Иван", 30)\nвывести иван.получить_возраст()',
        "expectedOutput": '30\n',
    },
    {
        "title": 'Урок 50: Статические методы',
        "instruction": 'Создайте статический метод в классе, который не зависит от состояния объекта.\n\nТеория: Статические методы принадлежат классу, а не объекту. Их можно вызывать прямо от имени класса, не создавая экземпляр. Они полезны для вспомогательных функций, логически связанных с классом.',
        "example": 'См. код урока.',
        "homework": 'Домашнее задание: В классе `Калькулятор` создайте статические методы `сложить(a, b)`, `вычесть(a, b)` и `умножить(a, b)`.',
        "code": 'определить класс Утилиты:\n    определить статический метод это_выходной(день):\n        вернуть день == "суббота" или день == "воскресенье"\n    конец\nконец\n\nвывести Утилиты.это_выходной("воскресенье")',
        "expectedOutput": 'истина\n',
    },
    {
        "title": 'Урок 51: Декораторы (симуляция)',
        "instruction": 'Создайте симуляцию декоратора, который "оборачивает" другую функцию, добавляя функциональность до и после ее вызова.\n\nТеория: Декоратор — это функция, которая принимает другую функцию и расширяет ее поведение, не изменяя ее код. Это мощный инструмент для метапрограммирования.',
        "example": 'См. код урока.',
        "homework": 'Домашнее задание: Напишите декоратор `таймер`, который замеряет и выводит время выполнения обернутой им функции.',
        "code": 'определить декоратор_журнала(функция):\n    определить обертка():\n        вывести "Начало выполнения функции."\n        функция()\n        вывести "Конец выполнения функции."\n    конец\n    вернуть обертка\nконец\n\nопределить основная_логика():\n    вывести "--- Основная логика работает ---"\nконец\n\nустановить украшенная_функция в декоратор_журнала(основная_логика)\nукрашенная_функция()',
        "expectedOutput": 'Начало выполнения функции.\n--- Основная логика работает ---\nКонец выполнения функции.\n',
    },
]

# --- HTML ШАБЛОН ---
HTML_TEMPLATE = """
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Интерактивный учебник "РунетКод"</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .font-mono { font-family: 'JetBrains Mono', monospace; }
        .sidebar { -ms-overflow-style: none; scrollbar-width: none; }
        .sidebar::-webkit-scrollbar { display: none; }
    </style>
</head>
<body class="bg-slate-100 text-slate-800">
    <div class="flex h-screen">
        <!-- Боковая панель с уроками -->
        <aside class="w-1/4 bg-white border-r border-slate-200 flex flex-col sidebar overflow-y-auto">
            <div class="p-4 border-b border-slate-200">
                <h1 class="text-xl font-bold text-slate-900">🚀 РунетКод</h1>
                <p class="text-sm text-slate-500">Интерактивный курс</p>
            </div>
            <nav class="flex-grow">
                <ul>
                    {% for i in range(lessons|length) %}
                    <li>
                        <a href="{{ url_for('index', lesson_id=i) }}" 
                           class="block px-4 py-3 text-sm hover:bg-slate-100 transition-colors
                                  {% if i == current_lesson_id %} bg-blue-50 border-r-4 border-blue-500 text-blue-700 font-semibold {% endif %}">
                            Урок {{ i + 1 }}: {{ lessons[i].title }}
                        </a>
                    </li>
                    {% endfor %}
                </ul>
            </nav>
        </aside>

        <!-- Основной контент -->
        <main class="w-3/4 flex flex-col p-6 bg-slate-50">
            <div class="flex-grow flex flex-col lg:flex-row gap-6">
                
                <!-- Левая колонка: Инструкции и теория -->
                <div class="lg:w-1/2 flex flex-col gap-4">
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h2 class="text-2xl font-bold mb-3 text-slate-900">{{ lesson.title }}</h2>
                        <p class="text-slate-600 whitespace-pre-wrap">{{ processed_instruction | safe }}</p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-lg font-semibold mb-2 text-slate-800">Пример</h3>
                        <pre class="bg-slate-100 p-3 rounded-md text-sm font-mono text-slate-700 whitespace-pre-wrap"><code>{{ lesson.example }}</code></pre>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-lg font-semibold mb-2 text-slate-800">Домашнее задание</h3>
                        <p class="text-slate-600 whitespace-pre-wrap">{{ lesson.homework }}</p>
                    </div>
                </div>

                <!-- Правая колонка: Редактор кода и вывод -->
                <div class="lg:w-1/2 flex flex-col gap-4">
                    <form action="{{ url_for('run_code_route') }}" method="post" class="flex-grow flex flex-col bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <input type="hidden" name="lesson_id" value="{{ current_lesson_id }}">
                        <h3 class="text-lg font-semibold mb-2 text-slate-800">Ваш код</h3>
                        <textarea name="code" class="w-full flex-grow p-3 border border-slate-300 rounded-md font-mono text-sm bg-slate-50 focus:ring-2 focus:ring-blue-500 focus:outline-none" rows="12">{{ user_code }}</textarea>
                        <button type="submit" class="mt-4 w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors shadow-sm">
                            Выполнить
                        </button>
                    </form>
                    
                    <div class="bg-gray-800 p-6 rounded-lg shadow-sm border border-slate-700">
                        <h3 class="text-lg font-semibold mb-2 text-gray-300">Вывод программы:</h3>
                        <pre class="bg-gray-900 p-3 rounded-md text-sm font-mono text-white whitespace-pre-wrap h-40 overflow-y-auto">{% if error %}<span class="text-red-400">{{ error }}</span>{% else %}{{ output }}{% endif %}</pre>
                        
                        {% if result_status is not none %}
                            <div class="mt-4 p-3 rounded-md text-sm font-semibold
                                {% if result_status %} bg-green-100 text-green-800 {% else %} bg-red-100 text-red-800 {% endif %}">
                                {% if result_status %}
                                    ✅ Правильно! Вывод совпадает с ожидаемым.
                                {% else %}
                                    ❌ Ошибка. Вывод не совпадает с ожидаемым.
                                {% endif %}
                            </div>
                        {% endif %}
                    </div>
                </div>
            </div>
        </main>
    </div>
</body>
</html>
"""

# --- ИНТЕРПРЕТАТОР ЯЗЫКА (ИСПРАВЛЕННАЯ ВЕРСИЯ) ---
RU_LETTERS = "абвгдеёжзийклмнопрстуфхцчшщъыьэюяАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"
IDENTIFIER_PATTERN = f"[{RU_LETTERS}a-zA-Z_][{RU_LETTERS}a-zA-Z0-9_]*"

class InterpreterError(Exception):
    def __init__(self, message, line_num=None):
        self.message = message
        self.line_num = line_num
        super().__init__(self.message)

    def __str__(self):
        if self.line_num is not None:
            return f'Ошибка на строке {self.line_num + 1}: {self.message}'
        return f'Ошибка: {self.message}'

class Function:
    def __init__(self, name, params, defaults, body, defining_scope, is_static=False):
        self.name, self.params, self.defaults, self.body, self.defining_scope, self.is_static, self.is_method = name, params, defaults, body, defining_scope, is_static, False

class ClassDefinition:
    def __init__(self, name, parent=None):
        self.name, self.parent_name, self.methods, self.class_vars = name, parent, {}, {}

class ClassInstance:
    def __init__(self, class_def):
        self.class_def, self.instance_vars = class_def, {}

class MockFile:
    def __init__(self, content=""): self.content = content
    def записать(self, text): self.content += str(text)
    def прочитать(self): return self.content

class Interpreter:
    def __init__(self):
        self.global_scope, self.mock_files = {}, {}

    def _get_base_scope(self):
        class MathModule:
            пи = math.pi
            def корень(self, x): return math.sqrt(x)
            def степень(self, x, y): return math.pow(x, y)
        class RandomModule:
            def число(self, a, b): return random.randint(a, b)
            def выбор(self, seq): return random.choice(seq)
        class JsonModule:
            def выгрузить(self, obj, indent=None): return json.dumps(obj, ensure_ascii=False, indent=indent)
            def загрузить(self, s): return json.loads(s)
        class TimeModule:
            def сейчас(self): return datetime.datetime.now()
            def формат(self, dt, fmt): return dt.strftime(fmt)
        class WebModule:
            def запрос(self, url):
                if "data" in url: return '{"сообщение": "Успех!", "статус": 200}'
                return '{"ошибка": "Не найдено"}'
        
        return {
            'Математика': MathModule(), 'Случайный': RandomModule(), 'джейсон': JsonModule(),
            'время': TimeModule(), 'веб': WebModule(), 'длина': len, 'диапазон': range,
            'множество': set, 'список': list, 'строка': str, 'число': int,
            'вывести': print, 'истина': True, 'ложь': False, 'None': None
        }

    def _split_respecting_nesting(self, text, delimiter=','):
        items, current_item, level, in_quotes, quote_char = [], "", 0, False, None
        for char in text:
            if char in ('"', "'") and quote_char is None: in_quotes, quote_char = True, char
            elif char == quote_char: in_quotes, quote_char = False, None
            elif not in_quotes:
                if char in '([{': level += 1
                elif char in ')]}': level -= 1
                elif char == delimiter and level == 0:
                    items.append(current_item.strip()); current_item = ""
                    continue
            current_item += char
        if current_item.strip(): items.append(current_item.strip())
        return items

    def _evaluate(self, expression, scope):
        expression = expression.strip()
        
        lambda_match = re.match(r'^лямбда\s+([^:]+):\s*(.+)$', expression)
        if lambda_match:
            params_str, body_expr = lambda_match.groups()
            params = [p.strip() for p in params_str.split(',')]
            def lambda_func(*args):
                lambda_scope = scope.copy()
                for i, param in enumerate(params):
                    if i < len(args):
                        lambda_scope[param] = args[i]
                return self._evaluate(body_expr, lambda_scope)
            return lambda_func

        if (expression.startswith('"') and expression.endswith('"')) or (expression.startswith("'") and expression.endswith("'")):
            try: return eval(expression, {}, {})
            except Exception as e: raise InterpreterError(f"Некорректная строка: {expression}. Ошибка: {e}")

        call_target_match = re.match(fr'^({IDENTIFIER_PATTERN}(?:\.{IDENTIFIER_PATTERN}|\[.*?\])*)\s*\(', expression)
        if call_target_match and expression.endswith(')'):
            target_expr = call_target_match.group(1)
            args_str = expression[len(call_target_match.group(0)):-1]
            
            if '.' in target_expr:
                obj_expr, method_name = target_expr.rsplit('.', 1)
                obj = self._evaluate(obj_expr, scope)
                py_method_name = {'вверх': 'upper', 'ключи': 'keys', 'значения': 'values', 'сортировать': 'sort', 'записать': 'записать', 'прочитать': 'прочитать'}.get(method_name, method_name)
                if isinstance(obj, ClassInstance):
                    method = self._find_method(obj.class_def, method_name, scope)
                    if not method: raise InterpreterError(f"Метод '{method_name}' не найден.")
                    return self._call_function_or_method(method, args_str, scope, obj)
                elif isinstance(obj, ClassDefinition):
                    method = self._find_method(obj, method_name, scope)
                    if not method or not method.is_static: raise InterpreterError(f"Статический метод '{method_name}' не найден.")
                    return self._call_function_or_method(method, args_str, scope)
                elif hasattr(obj, py_method_name):
                    method_obj = getattr(obj, py_method_name)
                    args = self._evaluate_args(args_str, scope)
                    if method_name == 'сортировать': obj.sort(); return obj
                    result = method_obj(*args) if callable(method_obj) else method_obj
                    if py_method_name in ['keys', 'values']:
                        return list(result)
                    return result
            else:
                func = scope.get(target_expr)
                if isinstance(func, Function): return self._call_function_or_method(func, args_str, scope)
                if callable(func): return func(*self._evaluate_args(args_str, scope))

        replacements = { r'\bи\b': 'and', r'\bили\b': 'or', r'\bне\b': 'not', r'\bистина\b': 'True', r'\bложь\b': 'False' }
        for rus, eng in replacements.items(): expression = re.sub(rus, eng, expression)

        if contains_match := re.search(r'\s+содержит\s+', expression):
            container_expr, item_expr = re.split(r'\s+содержит\s+', expression, maxsplit=1)
            return self._evaluate(item_expr, scope) in self._evaluate(container_expr, scope)

        if comp_match := re.match(fr'\[(.+?)\s+для\s+({IDENTIFIER_PATTERN})\s+в\s+(.+?)\]', expression):
            expr, var, iterable_expr = comp_match.groups()
            return [self._evaluate(expr, {**scope, var: item}) for item in self._evaluate(iterable_expr, scope)]

        if new_match := re.match(fr'новый\s+({IDENTIFIER_PATTERN})\s*\((.*)\)', expression):
            class_name, args_str = new_match.groups()
            class_def = scope.get(class_name)
            if not isinstance(class_def, ClassDefinition): raise InterpreterError(f"Класс '{class_name}' не определен.")
            instance = ClassInstance(class_def)
            if init_method := self._find_method(class_def, '__init__', scope):
                self._call_function_or_method(init_method, args_str, scope, instance)
            return instance

        if attr_match := re.match(fr'({IDENTIFIER_PATTERN}(?:\.{IDENTIFIER_PATTERN}|\[.*?\])*)', expression) and '.' in expression:
            obj_expr, attr = expression.rsplit('.', 1)
            obj = self._evaluate(obj_expr, scope)
            if isinstance(obj, ClassInstance):
                if attr in obj.instance_vars: return obj.instance_vars[attr]
                current_class = obj.class_def
                while current_class:
                    if attr in current_class.class_vars: return current_class.class_vars[attr]
                    current_class = scope.get(current_class.parent_name) if current_class.parent_name else None
                raise InterpreterError(f"Атрибут '{attr}' не найден")
            elif hasattr(obj, attr): return getattr(obj, attr)

        if expression.startswith('[') and expression.endswith(']'): return [self._evaluate(item, scope) for item in self._split_respecting_nesting(expression[1:-1])] if expression[1:-1] else []
        if expression.startswith('{') and expression.endswith('}'):
            if not (content := expression[1:-1].strip()): return {}
            return {self._evaluate(k, scope): self._evaluate(v, scope) for k, v in (p.split(':', 1) for p in self._split_respecting_nesting(content))}

        eval_scope = scope.copy()
        for key, value in scope.items():
            if isinstance(value, Function):
                eval_scope[key] = (lambda f, s: lambda *args: self._call_function_from_eval(f, args, s))(value, scope)
        try:
            return eval(expression, self.global_scope, eval_scope)
        except Exception as e:
            raise InterpreterError(f"Не удалось вычислить выражение '{expression}'. Ошибка: {e}")

    def _call_function_from_eval(self, func, args, calling_scope):
        call_scope = {**self.global_scope, **func.defining_scope}
        for i, param_name in enumerate(func.params):
            if i < len(args): call_scope[param_name] = args[i]
            elif param_name in func.defaults: call_scope[param_name] = self._evaluate(func.defaults[param_name], calling_scope)
            else: raise InterpreterError(f"Отсутствует аргумент '{param_name}' для '{func.name}'")
        res = self._execute_block(func.body, call_scope)
        return res.get('return') if res else None

    def _evaluate_args(self, args_str, scope):
        return [self._evaluate(arg, scope) for arg in self._split_respecting_nesting(args_str)] if args_str.strip() else []

    def _find_method(self, class_def, method_name, scope):
        current_class = class_def
        while current_class:
            if method_name in current_class.methods: return current_class.methods[method_name]
            current_class = scope.get(current_class.parent_name) if current_class.parent_name else None
        return None

    def _call_function_or_method(self, func, args_str, scope, instance=None):
        args, call_scope = self._evaluate_args(args_str, scope), {**self.global_scope, **func.defining_scope}
        if instance and func.is_method: call_scope.update({**instance.class_def.class_vars, **instance.instance_vars, 'это': instance})
        for i, param_name in enumerate(func.params):
            if i < len(args): call_scope[param_name] = args[i]
            elif param_name in func.defaults: call_scope[param_name] = self._evaluate(func.defaults[param_name], scope)
            else: raise InterpreterError(f"Отсутствует аргумент '{param_name}' для '{func.name}'")
        res = self._execute_block(func.body, call_scope)
        return res.get('return') if res else None

    def _find_block_end(self, lines, start_index):
        level, i = 1, start_index + 1
        block_starters = [r'^\s*если .* тогда', r'^\s*пока .* тогда', r'^\s*для каждого .*:', r'^\s*повторять .* раз:', r'^\s*определить .*:', r'^\s*открыть .*:', r'^\s*попытаться:']
        while i < len(lines):
            line = lines[i].strip()
            if any(re.match(p, line) for p in block_starters): level += 1
            if re.match(r'^\s*конец\s*$', line):
                level -= 1
                if level == 0: return i
            i += 1
        raise InterpreterError("Не найден 'конец' для блока", line_num=start_index)
    
    def _prepare_code(self, code):
        lines = [line for line in code.split('\n')]
        processed_lines = []
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i+=1
                continue

            paren_count = line.count('(') - line.count(')')
            bracket_count = line.count('[') - line.count(']')
            
            while (paren_count > 0 or bracket_count > 0) and i + 1 < len(lines):
                i += 1
                next_line = lines[i].strip()
                line += " " + next_line
                paren_count += next_line.count('(') - next_line.count(')')
                bracket_count += next_line.count('[') - next_line.count(']')
            
            processed_lines.append(line)
            i += 1
        return processed_lines

    def run(self, code):
        self.global_scope, self.mock_files = self._get_base_scope(), {}
        output_capture = StringIO()
        
        prepared_lines = self._prepare_code(code)
        
        with redirect_stdout(output_capture):
            try: 
                self._execute_block(prepared_lines, self.global_scope)
            except InterpreterError as e: 
                print(e, end='')
            except Exception as e:
                import traceback; 
                traceback.print_exc()
                print(f"Критическая ошибка Python: {type(e).__name__}: {e}", end='')
        return output_capture.getvalue()

    def _execute_block(self, lines, scope, in_loop=False):
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line or line.startswith('#'): i += 1; continue
            
            try:
                if match := re.match(r'^\s*если\s+(.+?)\s+тогда\s*', line):
                    end_if_block = self._find_block_end(lines, i)
                    if_chain = lines[i : end_if_block + 1]
                    current_pos, executed = 0, False
                    while current_pos < len(if_chain) - 1:
                        current_line = if_chain[current_pos].strip()
                        if_match = re.match(r"^\s*если\s+(.+?)\s+тогда", current_line)
                        elif_match = re.match(r"^\s*иначе\s+если\s+(.+?)\s+тогда", current_line)
                        else_match = re.match(r"^\s*иначе\s*:?$", current_line)

                        if if_match or elif_match or else_match:
                            block_start = current_pos + 1
                            block_end = block_start
                            level = 1
                            while block_end < len(if_chain) -1:
                                next_line_in_chain = if_chain[block_end].strip()
                                if any(re.match(p, next_line_in_chain) for p in [r'^\s*если .* тогда', r'^\s*пока .* тогда', r'^\s*для каждого .*:', r'^\s*повторять .* раз:', r'^\s*определить .*:', r'^\s*открыть .*:', r'^\s*попытаться:']):
                                    level += 1
                                if re.match(r'^\s*конец\s*$', next_line_in_chain):
                                    level -= 1
                                
                                if level <= 0 or re.match(r'^\s*иначе', next_line_in_chain):
                                    break
                                block_end += 1

                            should_execute = False
                            if not executed:
                                if if_match: should_execute = self._evaluate(if_match.group(1), scope)
                                elif elif_match: should_execute = self._evaluate(elif_match.group(1), scope)
                                else: should_execute = True
                            
                            if should_execute:
                                res = self._execute_block(if_chain[block_start:block_end], scope, in_loop)
                                if res: return res
                                executed = True

                            current_pos = block_end
                        else:
                            current_pos += 1
                    i = end_if_block

                elif match := re.match(fr'^\s*определить\s+(?:(статический)\s+метод\s+)?({IDENTIFIER_PATTERN})\s*\(([^)]*)\)\s*:\s*', line):
                    is_static, name, params_str = match.groups()
                    end_func = self._find_block_end(lines, i); body = lines[i+1:end_func]; params, defaults = [], {}
                    if params_str:
                        for part in self._split_respecting_nesting(params_str):
                            if '=' in part: pname, dval = part.split('=', 1); params.append(pname.strip()); defaults[pname.strip()] = dval.strip()
                            else: params.append(part.strip())
                    func = Function(name, params, defaults, body, scope, bool(is_static))
                    if isinstance(scope.get('__class_self__'), ClassDefinition): func.is_method = True; scope['__class_self__'].methods[name] = func
                    else: scope[name] = func; self.global_scope[name] = func
                    i = end_func
                elif match := re.match(fr'^\s*определить\s+класс\s+({IDENTIFIER_PATTERN})\s*(?:наследует\s+({IDENTIFIER_PATTERN}))?\s*:\s*', line):
                    class_name, parent_name = match.groups(); end_class = self._find_block_end(lines, i)
                    class_def = ClassDefinition(class_name, parent_name); scope[class_name] = class_def
                    class_scope = {**scope, **class_def.class_vars, '__class_self__': class_def}
                    self._execute_block(lines[i+1:end_class], class_scope)
                    class_def.class_vars.update({k:v for k,v in class_scope.items() if k not in scope and k != '__class_self__'})
                    i = end_class
                elif match := re.match(fr'^\s*повторять\s+(.+?)\s+раз:\s*', line):
                    count = int(self._evaluate(match.group(1), scope)); end_loop = self._find_block_end(lines, i); body = lines[i+1:end_loop]
                    for it_index in range(count):
                        if res := self._execute_block(body, {**scope, 'i': it_index}, True):
                            if res.get('break'): break
                            if res.get('continue'): continue
                            if 'return' in res: return res
                    i = end_loop
                elif match := re.match(r'^\s*пока\s+(.+?)\s+тогда\s*', line):
                    end_while = self._find_block_end(lines, i); body = lines[i+1:end_while]
                    while self._evaluate(match.group(1), scope):
                        if res := self._execute_block(body, scope, True):
                            if res.get('break'): break
                            if res.get('continue'): continue
                            if 'return' in res: return res
                    i = end_while
                elif match := re.match(fr'^\s*для каждого\s+({IDENTIFIER_PATTERN})\s+в\s+(.+?):\s*', line):
                    var_name, iterable_expr = match.groups(); end_loop = self._find_block_end(lines, i); body = lines[i+1:end_loop]
                    for item in self._evaluate(iterable_expr, scope):
                        if res := self._execute_block(body, {**scope, var_name: item}, True):
                            if res.get('break'): break
                            if res.get('continue'): continue
                            if 'return' in res: return res
                    i = end_loop
                elif re.match(r'^\s*попытаться:\s*', line):
                    end_try_block = self._find_block_end(lines, i); try_body, catch_body, finally_body, block_lines = [], [], [], lines[i+1:end_try_block]
                    catch_pos = next((idx for idx, l in enumerate(block_lines) if re.match(r'^\s*поймать:\s*', l)), -1)
                    finally_pos = next((idx for idx, l in enumerate(block_lines) if re.match(r'^\s*наконец:\s*', l)), -1)
                    if catch_pos != -1:
                        try_body = block_lines[:catch_pos]
                        if finally_pos != -1: catch_body, finally_body = block_lines[catch_pos+1:finally_pos], block_lines[finally_pos+1:]
                        else: catch_body = block_lines[catch_pos+1:]
                    elif finally_pos != -1: try_body, finally_body = block_lines[:finally_pos], block_lines[finally_pos+1:]
                    else: try_body = block_lines
                    try: self._execute_block(try_body, scope, in_loop)
                    except Exception:
                        if catch_body: self._execute_block(catch_body, scope, in_loop)
                    finally:
                        if finally_body: self._execute_block(finally_body, scope, in_loop)
                    i = end_try_block
                elif match := re.match(fr'^\s*открыть\s+"([^"]+)"\s+для\s+(записи|чтения)\s+как\s+({IDENTIFIER_PATTERN}):\s*', line):
                    file_name, mode, var_name = match.groups(); end_file_block = self._find_block_end(lines, i)
                    if mode == "записи": self.mock_files[file_name] = MockFile()
                    elif file_name not in self.mock_files: self.mock_files[file_name] = MockFile("")
                    self._execute_block(lines[i+1:end_file_block], {**scope, var_name: self.mock_files[file_name]}, in_loop)
                    i = end_file_block
                elif match := re.match(r'^\s*вывести\s*(.*)', line):
                    val_str = match.group(1).strip()
                    if val_str.startswith('ф"'):
                        print(re.sub(r'\{(.+?)\}', lambda m: str(self._evaluate(m.group(1), scope)), val_str[2:-1]))
                    else:
                        value = self._evaluate(val_str, scope)
                        if isinstance(value, dict):
                            print(str(value).replace("'", '"')) # Для словарей
                        else:
                            print('истина' if value is True else 'ложь' if value is False else value)
                elif match := re.match(fr'^\s*(установить|изменить)\s+(.+?)\s+в\s+(.*)', line, re.DOTALL):
                    _, target, value_expr = match.groups(); target = target.strip(); value = self._evaluate(value_expr, scope)
                    if '[' in target and target.endswith(']'):
                        var_name, index_expr = target[:-1].split('[', 1)
                        self._evaluate(var_name, scope)[self._evaluate(index_expr, scope)] = value
                    elif '.' in target:
                        obj_name, attr = target.split('.', 1); obj = scope.get(obj_name)
                        if isinstance(obj, ClassInstance): obj.instance_vars[attr] = value
                        elif isinstance(obj, ClassDefinition): obj.class_vars[attr] = value
                    else: scope[target] = value
                
                elif (match := re.match(fr'^\s*({IDENTIFIER_PATTERN})\s+в\s+(.*)', line, re.DOTALL)) and isinstance(scope.get('__class_self__'), ClassDefinition):
                    var_name, value_expr = match.groups()
                    value = self._evaluate(value_expr, scope)
                    scope['__class_self__'].class_vars[var_name] = value

                elif match := re.match(r'^\s*это\.(.+?)\s+в\s+(.*)', line, re.DOTALL):
                    if isinstance(obj := scope.get('это'), ClassInstance): obj.instance_vars[match.groups()[0]] = self._evaluate(match.groups()[1], scope)
                    else: raise InterpreterError("'это' доступно только в методах класса")
                elif match := re.match(fr'^\s*добавить\s+(.+?)\s+в\s+({IDENTIFIER_PATTERN})\s*', line): scope[match.group(2)].append(self._evaluate(match.group(1), scope))
                elif match := re.match(r'^\s*удалить\s+(.+)\s*', line):
                    target = match.group(1).strip()
                    if '[' in target and target.endswith(']'): var_name, index_expr = target[:-1].split('[', 1); del self._evaluate(var_name, scope)[self._evaluate(index_expr.strip(), scope)]
                    else: del scope[target]
                elif line == 'прервать': return {'break': True}
                elif line == 'продолжить': return {'continue': True}
                elif match := re.match(r'^\s*вернуть\s*(.*)', line): return {'return': self._evaluate(match.group(1), scope) if match.group(1) else None}
                elif re.match(r'^\s*импорт', line): pass
                elif re.match(fr'^{IDENTIFIER_PATTERN}(?:\.{IDENTIFIER_PATTERN}|\[.*?\])*\s*\(.*\)\s*$', line): self._evaluate(line, scope)
                elif not any(re.match(p, line) for p in [r'^\s*конец', r'^\s*иначе\s*:?$', r'^\s*иначе если', r'^\s*поймать', r'^\s*наконец']): raise InterpreterError(f"Неизвестная команда или синтаксическая ошибка: {line}")
            except InterpreterError as e:
                if e.line_num is None: e.line_num = i
                raise e
            except Exception as e:
                import traceback; traceback.print_exc()
                raise InterpreterError(f"Внутренняя ошибка Python: {type(e).__name__}: {e}", line_num=i)
            i += 1
        return None

# --- FLASK ПРИЛОЖЕНИЕ ---
app = Flask(__name__)

def compare_outputs(actual, expected):
    """Улучшенная функция для сравнения вывода."""
    norm_actual = "\n".join(sorted(line.strip() for line in actual.strip().splitlines()))
    norm_expected = "\n".join(sorted(line.strip() for line in expected.strip().splitlines()))

    if norm_actual == norm_expected:
        return True

    if norm_expected.startswith('{') and norm_expected.endswith('}'):
        try:
            actual_set = eval(norm_actual.replace("'", '"'))
            expected_set = eval(norm_expected)
            if isinstance(actual_set, set) and isinstance(expected_set, set) and actual_set == expected_set:
                return True
        except: pass

    if norm_expected == 'истина' and norm_actual.lower() == 'true':
        return True
    if norm_expected == 'ложь' and norm_actual.lower() == 'false':
        return True
        
    try:
        actual_list = sorted(eval(norm_actual.replace("'", '"')))
        expected_list = sorted(eval(norm_expected.replace("'", '"')))
        if actual_list == expected_list:
            return True
    except: pass

    return False

@app.route('/')
def index_redirect():
    return redirect(url_for('index', lesson_id=0))

@app.route('/lesson/<int:lesson_id>')
def index(lesson_id):
    if not 0 <= lesson_id < len(lessons):
        return redirect(url_for('index', lesson_id=0))
    
    lesson = lessons[lesson_id]
    lesson['instruction'] = lesson.get('instruction', 'Инструкция к уроку отсутствует.')
    lesson['example'] = lesson.get('example', 'Пример отсутствует.')
    lesson['homework'] = lesson.get('homework', 'Домашнее задание отсутствует.')
    
    processed_instruction = re.sub(r'`([^`]+)`', r'<code class="bg-slate-200 text-slate-800 px-1 py-0.5 rounded">\1</code>', lesson['instruction'])
    
    return render_template_string(
        HTML_TEMPLATE, 
        lessons=lessons, 
        lesson=lesson,
        current_lesson_id=lesson_id,
        user_code=lesson.get('code', ''),
        output='',
        error='',
        result_status=None,
        processed_instruction=processed_instruction
    )

@app.route('/run', methods=['POST'])
def run_code_route():
    user_code = request.form['code']
    lesson_id = int(request.form['lesson_id'])
    
    lesson = lessons[lesson_id]
    
    interpreter = Interpreter()
    result = interpreter.run(user_code)
    
    output = ''
    error = ''
    if result.startswith('Ошибка'):
        error = result
    else:
        output = result
        
    result_status = None
    if not error:
        expected_output = lesson.get('expectedOutput', '')
        
        is_correct = False
        if lesson_id + 1 == 47: # Урок 47: Случайные числа
             is_correct = 'истина' in output.lower()
        elif lesson_id + 1 == 42: # Урок 42: Дата и время
            is_correct = bool(re.match(r'^\d{4}-\d{2}-\d{2}', output.strip()))
        else:
            is_correct = compare_outputs(output, expected_output)
        
        result_status = is_correct

    lesson['instruction'] = lesson.get('instruction', 'Инструкция к уроку отсутствует.')
    lesson['example'] = lesson.get('example', 'Пример отсутствует.')
    lesson['homework'] = lesson.get('homework', 'Домашнее задание отсутствует.')
    processed_instruction = re.sub(r'`([^`]+)`', r'<code class="bg-slate-200 text-slate-800 px-1 py-0.5 rounded">\1</code>', lesson['instruction'])

    return render_template_string(
        HTML_TEMPLATE,
        lessons=lessons,
        lesson=lesson,
        current_lesson_id=lesson_id,
        user_code=user_code,
        output=output,
        error=error,
        result_status=result_status,
        processed_instruction=processed_instruction
    )

if __name__ == '__main__':
    app.run(debug=True)
